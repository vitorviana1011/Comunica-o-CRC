//define os tipos de codifica√ß√£o
#define NRZ_L 1
#define NRZ_I 2
#define ENCODING NRZ_L

//define o pin que o led estar√° inserido
#define LED_PIN 11
const int bit_duration = 150;//dura√ß√£o padr√£o do bit para sincronizar
String msg = "Versao grande final";//frase que ser√° enviada

//estado do led para a codifica√ß√£o NRZ-I
int ledStateNRZI = LOW;

//c√°lculo do CRC
//0x8C (que representa o polin√¥mio reverso de 0x31, ou seja, ùë•^8+ùë•^5+ùë•^4+1)
byte calculaCRC8(const byte *data, size_t len) {
  byte crc = 0x00;
  while (len--) {
    byte extract = *data++;//bit atual
    for (byte tempI = 8; tempI; tempI--) {
      //Faz o XOR entre crc e extract, mas s√≥ compara o bit menos significativo (LSB) com & 0x01.
      byte sum = (crc ^ extract) & 0x01;
      //desloca o CRC para a direita
      crc >>= 1;
      //Se sum == 1, faz XOR de crc com 0x8C. Isso √© a aplica√ß√£o do polin√¥mio CRC-8
      if (sum) { crc ^= 0x8C; }
      extract >>= 1;
    }//for
  }//while
  //retorna o valor final do CRC
  return crc;
}//calculaCRC8

//caso a codifica√ß√£o for NRZ-L
void send_bit_nrzl(int bit) {
  if (bit == 1) digitalWrite(LED_PIN, HIGH);//se o bit for 1, envia luz acesa
  else digitalWrite(LED_PIN, LOW);//se o bit for 0, envia luza apagada
  delay(bit_duration);
}//send_bit_nrzl

//caso a codifica√ß√£o for NRZ-I
void send_bit_nrzi(int bit) {
  if (bit == 1) {
    ledStateNRZI = !ledStateNRZI;//se o bit for 1, o estado do bit √© invertido, caso contr√°rio, mant√©m o estado
  }//if
  digitalWrite(LED_PIN, ledStateNRZI);//√© enviado o resultado dessa compara√ß√£o
  delay(bit_duration);
}//send_bit_nrzi

//determina qual o tipo de codifica√ß√£o ser√° realizada
void send_bit(int bit) {
  if (ENCODING == NRZ_L) {
    //codifica√ß√£o NRZ-L
    send_bit_nrzl(bit);
  } else if (ENCODING == NRZ_I) {
    //codifica√ß√£o NRZ-I
    send_bit_nrzi(bit);
  }//else if
}//send_bit

//tranforma o caractere em bits
void send_byte(char c) {
  for (int i = 7; i >= 0; i--) {
    //desloca o byte c √† direita e compara com 1
    int bit = (c >> i) & 1;
    send_bit(bit);//envia o resultado da compara√ß√£o
  }//for
}//send_byte

//--------------- INICIO DO C√íDIGO -------------------------//
void setup() {
  pinMode(LED_PIN, OUTPUT);//define o led como sa√≠da
  Serial.begin(9600);
  Serial.println(">>> Emissor Final (NRZ) Pronto.");
}//setup

//loop do c√≥digo
void loop() {
  //define o led como luz apagada e o estado do led como baixo
  digitalWrite(LED_PIN, LOW);
  ledStateNRZI = LOW;
  Serial.println("---------------------------------");
  //transmiss√µes s√£o realizadas automaticamente para n√£o ter interferencia manual de in√≠cio da sincroniza√ß√£o
  Serial.println("Nova transmissao automatica em 5 segundos...");
  delay(5000);

  //define o led com luz alta para iniciar
  digitalWrite(LED_PIN, LOW);
  delay(bit_duration * 5);

  //envia os 4 bits de sincroniza√ß√£o    
  send_bit(1);
  send_bit(0);
  send_bit(1);
  send_bit(0);
  
  //os outros 4 bits envia o tamanho da mensagem
  byte tamanho_msg = msg.length();
  send_byte((char)tamanho_msg);
  
  //ap√≥s enviar a sincroniza√ß√£o e o tamanho, envia a mensagem definitiva, byte por byte
  for (int i = 0; i < msg.length(); i++) {
    send_byte(msg[i]);
  }
  
  byte buffer[msg.length() + 1];
  msg.getBytes(buffer, msg.length() + 1); //copia os bytes de msg para o buffer para enviar ao c√°lculo do CRC
  byte crc_calculado = calculaCRC8(buffer, msg.length());
  send_byte(crc_calculado);
  
  //define o led apagado para acabar o processo e reiniciar o loop
  digitalWrite(LED_PIN, LOW);
}//loop
